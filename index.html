<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>LÃ¥ngviken</title>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="LÃ¥ngviken">
  <meta name="theme-color" content="#0d1117">

  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="manifest" href="manifest.json">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-date-fns/3.0.0/chartjs-adapter-date-fns.bundle.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    html, body {
      height: 100%;
      width: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: #0d1117;
      color: #e6edf3;
      min-height: 100vh;
      overflow-x: hidden;
    }

    #bg {
      position: fixed;
      inset: 0;
      background-color: #0d1117;
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: scroll;
      transition: background-image 1.5s ease-in-out;
      z-index: 0;
    }

    #bg::after {
      content: '';
      position: fixed;
      inset: 0;
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,0.60) 0%,
        rgba(0,0,0,0.20) 30%,
        rgba(0,0,0,0.20) 60%,
        rgba(0,0,0,0.75) 100%
      );
      z-index: 1;
    }

    #bg.loading {
      animation: bgPulse 2s infinite;
    }
    @keyframes bgPulse {
      0%, 100% { background-color: #0d1117; }
      50%       { background-color: #161b22; }
    }

    #page {
      position: relative;
      z-index: 2;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 10;
      background: rgba(13,17,23,0.55);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      padding: 16px 20px 14px;
      padding-top: max(env(safe-area-inset-top), 16px);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    header span { font-size: 1.5rem; }

    header h1 {
      font-size: 1.4rem;
      font-weight: 700;
      letter-spacing: -0.3px;
      color: #fff;
      text-shadow: 0 1px 8px rgba(0,0,0,0.5);
    }

    #last-updated {
      margin-left: auto;
      font-size: 0.75rem;
      color: rgba(255,255,255,0.55);
    }

    .status-pill {
      display: flex;
      align-items: center;
      gap: 5px;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 20px;
      padding: 4px 10px;
      font-size: 0.72rem;
      color: rgba(255,255,255,0.75);
    }

    .status-dot {
      width: 6px; height: 6px;
      border-radius: 50%;
      background: #22c55e;
      animation: pulse 2s infinite;
    }
    .status-dot.offline { background: #ef4444; animation: none; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50%       { opacity: 0.3; }
    }

    main {
      flex: 1;
      padding: 16px;
      padding-bottom: max(env(safe-area-inset-bottom), 16px);
      max-width: 1200px;
      width: 100%;
      margin: 0 auto;
    }

    #error-banner {
      display: none;
      background: rgba(61,31,31,0.85);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid #f85149;
      border-radius: 10px;
      padding: 12px 16px;
      margin-bottom: 16px;
      color: #f85149;
      font-size: 0.85rem;
    }

    .cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-bottom: 16px;
    }

    .card {
      background: rgba(22,27,34,0.55);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px 12px 12px;
      -webkit-tap-highlight-color: transparent;
      transition: transform 0.15s, border-color 0.15s;
    }
    .card:active {
      border-color: rgba(255,255,255,0.35);
      transform: scale(0.97);
    }

    .card-label {
      font-size: 0.66rem;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: rgba(255,255,255,0.55);
      margin-bottom: 7px;
    }

    .card-dot {
      width: 6px; height: 6px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 5px;
    }

    .card-value {
      font-size: 1.9rem;
      font-weight: 700;
      line-height: 1;
      color: #fff;
      text-shadow: 0 1px 6px rgba(0,0,0,0.4);
    }

    /* "Data saknas" styling â€” smaller, muted, italic */
    .card-value.no-data {
      font-size: 1rem;
      font-weight: 400;
      font-style: italic;
      color: rgba(255,255,255,0.30);
    }

    .card-unit {
      font-size: 0.85rem;
      font-weight: 400;
      color: rgba(255,255,255,0.55);
      margin-left: 2px;
    }

    .cam-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 14px;
    }

    .cam-info {
      font-size: 0.72rem;
      color: rgba(255,255,255,0.45);
    }

    .cam-btn {
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      color: rgba(255,255,255,0.75);
      font-size: 0.75rem;
      padding: 5px 14px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .cam-btn:active { background: rgba(255,255,255,0.15); }

    #refresh-hint {
      text-align: center;
      color: rgba(255,255,255,0.35);
      font-size: 0.72rem;
      padding: 6px 0 14px;
    }

    .charts {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    @media (min-width: 900px) {
      .charts { grid-template-columns: repeat(2, 1fr); }
    }

    .chart-box {
      background: rgba(22,27,34,0.60);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 16px 14px;
    }

    .chart-box h2 {
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 12px;
      color: rgba(255,255,255,0.85);
    }

    /* "Data saknas" overlay on charts */
    .chart-wrap {
      position: relative;
    }

    .chart-no-data {
      display: none;
      position: absolute;
      inset: 0;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      font-style: italic;
      color: rgba(255,255,255,0.30);
    }

    .chart-no-data.visible {
      display: flex;
    }

    #countdown {
      text-align: center;
      font-size: 0.70rem;
      color: rgba(255,255,255,0.30);
      padding: 6px 0 12px;
    }
  </style>
</head>
<body>

<div id="bg" class="loading"></div>

<div id="page">

  <header>
    <span>ðŸŒŠ</span>
    <h1>LÃ¥ngviken</h1>
    <div class="status-pill">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">â€“</span>
    </div>
    <div id="last-updated">Laddar...</div>
  </header>

  <main>
    <div id="error-banner"></div>

    <div class="cam-bar">
      <div class="cam-info" id="camTime">HÃ¤mtar bild...</div>
      <button class="cam-btn" onclick="fetchCamera()">â†» Ny bild</button>
    </div>

    <div class="cards">
      <div class="card">
        <div class="card-label">
          <span class="card-dot" style="background:#38bdf8"></span>Vattentemperatur
        </div>
        <div class="card-value" id="val-water">
          <span class="card-unit">Â°C</span>
        </div>
      </div>
      <div class="card">
        <div class="card-label">
          <span class="card-dot" style="background:#fb923c"></span>Inomhustemperatur
        </div>
        <div class="card-value" id="val-indoor">
          <span class="card-unit">Â°C</span>
        </div>
      </div>
      <div class="card">
        <div class="card-label">
          <span class="card-dot" style="background:#4ade80"></span>Utomhustemperatur
        </div>
        <div class="card-value" id="val-outdoor">
          <span class="card-unit">Â°C</span>
        </div>
      </div>
      <div class="card">
        <div class="card-label">
          <span class="card-dot" style="background:#c084fc"></span>Luftfuktighet
        </div>
        <div class="card-value" id="val-humidity">
          <span class="card-unit">%</span>
        </div>
      </div>
      <div class="card">
        <div class="card-label">
          <span class="card-dot" style="background:#f472b6"></span>Lufttryck
        </div>
        <div class="card-value" id="val-pressure">
          <span class="card-unit">mbar</span>
        </div>
      </div>
    </div>

    <div id="countdown"></div>

    <p id="refresh-hint">Dra nedÃ¥t fÃ¶r att uppdatera</p>

    <div class="charts">
      <div class="chart-box">
        <h2>ðŸŒ¡ Temperatur â€” 168h</h2>
        <div class="chart-wrap">
          <canvas id="chart-temp"></canvas>
          <div class="chart-no-data" id="no-data-temp">Data saknas</div>
        </div>
      </div>
      <div class="chart-box">
        <h2>ðŸ’§ Luftfuktighet &amp; Lufttryck â€” 168h</h2>
        <div class="chart-wrap">
          <canvas id="chart-hum-pres"></canvas>
          <div class="chart-no-data" id="no-data-humpres">Data saknas</div>
        </div>
      </div>
    </div>

  </main>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const AIO_USERNAME      = "Jollo77";
const AIO_KEY           = "aio_FvuD74yFPP9gXsjCr7TpdSMN3e2m";
const HOURS             = 168;
const CAMERA_REFRESH_MS = 3600000;

const FEEDS = {
  water:   "water-temperature",
  indoor:  "indoor-temperature",
  outdoor: "outdoor-temperature",
  hum:     "humidity",
  pres:    "pressure"
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ADAFRUIT IO HELPERS
//  Every function returns a safe value on failure â€”
//  [] for history, null for latest â€” never throws
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function aioUrl(feed) {
  const end   = new Date();
  const start = new Date(end - HOURS * 3600 * 1000);
  return `https://io.adafruit.com/api/v2/${AIO_USERNAME}/feeds/${feed}/data?` +
         `start_time=${start.toISOString()}&end_time=${end.toISOString()}&limit=1000` +
         `&X-AIO-Key=${AIO_KEY}`;
}

async function fetchFeed(feedKey) {
  try {
    const r = await fetch(aioUrl(FEEDS[feedKey]));
    if (!r.ok) {
      console.warn(`Feed "${feedKey}" HTTP ${r.status}`);
      return [];
    }
    const data = await r.json();
    if (!Array.isArray(data) || data.length === 0) return [];
    return data.reverse().map(d => ({
      x: new Date(d.created_at),
      y: parseFloat(d.value)
    }));
  } catch (e) {
    console.warn(`Feed "${feedKey}" failed:`, e.message);
    return [];
  }
}

async function fetchLatest(feedName) {
  try {
    const url = `https://io.adafruit.com/api/v2/${AIO_USERNAME}/feeds/${feedName}/data/last`;
    const r   = await fetch(url, { headers: { 'X-AIO-Key': AIO_KEY } });
    if (!r.ok) {
      console.warn(`fetchLatest "${feedName}" HTTP ${r.status}`);
      return null;
    }
    return await r.json();
  } catch (e) {
    console.warn(`fetchLatest "${feedName}" failed:`, e.message);
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TIME FORMATTERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function fmtTime(iso) {
  if (!iso) return 'â€“';
  return new Date(iso).toLocaleTimeString('sv-SE', {
    timeZone: 'Europe/Stockholm',
    hour: '2-digit', minute: '2-digit', second: '2-digit'
  });
}

function fmtDateTime(iso) {
  if (!iso) return 'â€“';
  return new Date(iso).toLocaleString('sv-SE', {
    timeZone: 'Europe/Stockholm',
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit'
  });
}

function fmtCountdown(totalSeconds) {
  const m = Math.floor(totalSeconds / 60);
  const s = totalSeconds % 60;
  return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CARD UPDATER
//  Shows the value if data exists, otherwise shows
//  "Data saknas" in a muted italic style
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateCard(id, points, decimals = 1) {
  const el   = document.getElementById(id);
  const unit = el.querySelector('.card-unit');

  if (!points || points.length === 0) {
    // No data â€” show "Data saknas", hide unit
    el.classList.add('no-data');
    unit.style.display = 'none';
    // Remove any previous value text node
    while (el.firstChild && el.firstChild !== unit) {
      el.removeChild(el.firstChild);
    }
    el.insertBefore(
      document.createTextNode('Data saknas'),
      unit
    );
    return;
  }

  // Data available â€” show value + unit normally
  el.classList.remove('no-data');
  unit.style.display = '';
  const latest = points[points.length - 1].y;
  while (el.firstChild && el.firstChild !== unit) {
    el.removeChild(el.firstChild);
  }
  el.insertBefore(
    document.createTextNode(latest.toFixed(decimals)),
    unit
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CAMERA / BACKGROUND
//  Completely isolated â€” failure here never affects
//  sensor cards or charts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let lastCameraFetch = 0;
let countdownTimer  = null;

async function fetchCamera() {
  try {
    console.log('Fetching camera-url feed...');
    const data = await fetchLatest('camera-url');

    if (!data || !data.value) {
      console.warn('camera-url feed empty or null');
      document.getElementById('camTime').textContent = 'Ingen bild Ã¤nnu';
      return;
    }

    console.log('Camera URL:', data.value);
    const url = data.value + '?t=' + Date.now();
    const bg  = document.getElementById('bg');

    const img    = new Image();
    img.onload   = () => {
      bg.classList.remove('loading');
      bg.style.backgroundImage = `url('${url}')`;
      console.log('Background image set OK');
    };
    img.onerror  = () => {
      console.warn('Background image load failed:', url);
      document.getElementById('camTime').textContent = 'Bild kunde inte laddas';
    };
    img.src = url;

    document.getElementById('camTime').textContent =
      'Tagen: ' + fmtDateTime(data.created_at);

    lastCameraFetch = Date.now();
    startCountdown();

  } catch (e) {
    console.warn('fetchCamera error (non-fatal):', e.message);
    document.getElementById('camTime').textContent = 'Kamerafel';
  }
}

function startCountdown() {
  if (countdownTimer) clearInterval(countdownTimer);
  const el = document.getElementById('countdown');
  countdownTimer = setInterval(() => {
    const elapsed   = Date.now() - lastCameraFetch;
    const remaining = Math.max(0,
      Math.floor((CAMERA_REFRESH_MS - elapsed) / 1000));
    el.textContent = remaining > 0
      ? `NÃ¤sta bild om ${fmtCountdown(remaining)}`
      : 'HÃ¤mtar ny bild...';
    if (remaining === 0) clearInterval(countdownTimer);
  }, 1000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHARTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const gridColor = "rgba(255,255,255,0.07)";
const tickColor = "rgba(255,255,255,0.45)";

function timeAxis() {
  return {
    type: "time",
    time: { unit: "day", displayFormats: { day: "EEE dd/MM" } },
    ticks: { color: tickColor, maxTicksLimit: 8 },
    grid:  { color: gridColor }
  };
}

function valueAxis(label) {
  return {
    ticks: { color: tickColor },
    grid:  { color: gridColor },
    title: { display: true, text: label, color: tickColor, font: { size: 10 } }
  };
}

let chartTemp = new Chart(
  document.getElementById("chart-temp").getContext("2d"), {
  type: "line",
  data: {
    datasets: [
      { label: "Vattentemperatur",  data: [], borderColor: "#38bdf8",
        backgroundColor: "rgba(56,189,248,0.10)",
        tension: 0.3, pointRadius: 0, borderWidth: 2, fill: true },
      { label: "Inomhustemperatur", data: [], borderColor: "#fb923c",
        backgroundColor: "rgba(251,146,60,0.10)",
        tension: 0.3, pointRadius: 0, borderWidth: 2, fill: true },
      { label: "Utomhustemperatur", data: [], borderColor: "#4ade80",
        backgroundColor: "rgba(74,222,128,0.10)",
        tension: 0.3, pointRadius: 0, borderWidth: 2, fill: true }
    ]
  },
  options: {
    responsive: true,
    interaction: { mode: "index", intersect: false },
    plugins: {
      legend: { labels: { color: "#e6edf3", boxWidth: 10, font: { size: 11 } } },
      tooltip: {
        callbacks: {
          label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)} Â°C`
        }
      }
    },
    scales: { x: timeAxis(), y: valueAxis("Â°C") }
  }
});

let chartHumPres = new Chart(
  document.getElementById("chart-hum-pres").getContext("2d"), {
  type: "line",
  data: {
    datasets: [
      { label: "Luftfuktighet (%)", data: [], borderColor: "#c084fc",
        backgroundColor: "rgba(192,132,252,0.10)",
        tension: 0.3, pointRadius: 0, borderWidth: 2, fill: true,
        yAxisID: "yHum" },
      { label: "Lufttryck (mbar)",  data: [], borderColor: "#f472b6",
        backgroundColor: "rgba(244,114,182,0.10)",
        tension: 0.3, pointRadius: 0, borderWidth: 2, fill: true,
        yAxisID: "yPres" }
    ]
  },
  options: {
    responsive: true,
    interaction: { mode: "index", intersect: false },
    plugins: {
      legend: { labels: { color: "#e6edf3", boxWidth: 10, font: { size: 11 } } },
      tooltip: {
        callbacks: {
          label: ctx => {
            const unit = ctx.dataset.yAxisID === "yHum" ? "%" : "mbar";
            return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)} ${unit}`;
          }
        }
      }
    },
    scales: {
      x:     timeAxis(),
      yHum:  { ...valueAxis("Luftfuktighet (%)"), position: "left",
               grid: { color: gridColor } },
      yPres: { ...valueAxis("Lufttryck (mbar)"),  position: "right",
               grid: { display: false } }
    }
  }
});

// Show or hide "Data saknas" overlay on a chart
function setChartNoData(overlayId, hasData) {
  const el = document.getElementById(overlayId);
  if (hasData) {
    el.classList.remove('visible');
  } else {
    el.classList.add('visible');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOAD SENSOR DATA
//  Promise.allSettled means every feed is attempted
//  independently â€” one failure never blocks others
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showError(msg) {
  const b = document.getElementById("error-banner");
  b.textContent   = "âš  " + msg;
  b.style.display = "block";
}

function clearError() {
  document.getElementById("error-banner").style.display = "none";
}

async function loadData() {
  try {
    clearError();
    console.log('Loading sensor data...');

    // allSettled â€” all feeds run regardless of individual failures
    const results = await Promise.allSettled([
      fetchFeed("water"),
      fetchFeed("indoor"),
      fetchFeed("outdoor"),
      fetchFeed("hum"),
      fetchFeed("pres")
    ]);

    // Safe extraction â€” [] if a feed failed at the Promise level
    const water   = results[0].status === 'fulfilled' ? results[0].value : [];
    const indoor  = results[1].status === 'fulfilled' ? results[1].value : [];
    const outdoor = results[2].status === 'fulfilled' ? results[2].value : [];
    const hum     = results[3].status === 'fulfilled' ? results[3].value : [];
    const pres    = results[4].status === 'fulfilled' ? results[4].value : [];

    console.log(
      `water:${water.length} indoor:${indoor.length} ` +
      `outdoor:${outdoor.length} hum:${hum.length} pres:${pres.length}`
    );

    // â”€â”€ Update sensor cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Each card independently shows value or "Data saknas"
    updateCard("val-water",    water);
    updateCard("val-indoor",   indoor);
    updateCard("val-outdoor",  outdoor);
    updateCard("val-humidity", hum,   1);
    updateCard("val-pressure", pres,  0);

    // â”€â”€ Update temperature chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    chartTemp.data.datasets[0].data = water;
    chartTemp.data.datasets[1].data = indoor;
    chartTemp.data.datasets[2].data = outdoor;
    chartTemp.update("none");

    // Show "Data saknas" on temp chart only if ALL three
    // temperature feeds are empty
    const hasTempData = water.length > 0 ||
                        indoor.length > 0 ||
                        outdoor.length > 0;
    setChartNoData('no-data-temp', hasTempData);

    // â”€â”€ Update humidity/pressure chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    chartHumPres.data.datasets[0].data = hum;
    chartHumPres.data.datasets[1].data = pres;
    chartHumPres.update("none");

    const hasHumPresData = hum.length > 0 || pres.length > 0;
    setChartNoData('no-data-humpres', hasHumPresData);

    // â”€â”€ Status indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const anyData = hasTempData || hasHumPresData;
    if (anyData) {
      document.getElementById("statusDot").classList.remove("offline");
      document.getElementById("statusText").textContent = "Online";
    } else {
      document.getElementById("statusDot").classList.add("offline");
      document.getElementById("statusText").textContent = "Ingen data";
    }

    document.getElementById("last-updated").textContent =
      "Senast: " + new Date().toLocaleTimeString("sv-SE", {
        timeZone: "Europe/Stockholm"
      });

  } catch (e) {
    // Safety net â€” should never reach here given individual
    // try/catch in fetchFeed, but included for completeness
    console.error('loadData unexpected error:', e);
    showError("Fel vid dataladdning: " + e.message);
    document.getElementById("statusDot").classList.add("offline");
    document.getElementById("statusText").textContent = "Offline";
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INITIALISE â€” camera and sensors fully independent
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Set all cards to "Data saknas" immediately on load
// so there is never a blank/broken state before data arrives
['val-water','val-indoor','val-outdoor','val-humidity','val-pressure']
  .forEach(id => updateCard(id, []));

loadData();
fetchCamera();

setInterval(loadData,    60000);
setInterval(fetchCamera, CAMERA_REFRESH_MS);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PULL-TO-REFRESH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let touchStartY = 0;

document.addEventListener("touchstart", e => {
  touchStartY = e.touches[0].clientY;
}, { passive: true });

document.addEventListener("touchend", e => {
  const diff = e.changedTouches[0].clientY - touchStartY;
  if (diff > 80 && window.scrollY === 0) {
    document.getElementById("refresh-hint").textContent = "Uppdaterar...";
    loadData();
    fetchCamera();
    setTimeout(() => {
      document.getElementById("refresh-hint").textContent =
        "Dra nedÃ¥t fÃ¶r att uppdatera";
    }, 3000);
  }
}, { passive: true });

</script>
</body>
</html>
